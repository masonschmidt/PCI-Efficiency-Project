<<<<<<< HEAD
__all__ = []

__metaclass__ = type
=======
__all__ = ['get_config_vars', 'get_path']

try:
    # Python 2.7 or >=3.2
    from sysconfig import get_config_vars, get_path
except ImportError:
    from distutils.sysconfig import get_config_vars, get_python_lib

    def get_path(name):
        if name not in ('platlib', 'purelib'):
            raise ValueError("Name must be purelib or platlib")
        return get_python_lib(name == 'platlib')
>>>>>>> 6fa881f75740879be432c459b9cab8a7b7aa2895


try:
    # Python >=3.2
    from tempfile import TemporaryDirectory
except ImportError:
    import shutil
    import tempfile

<<<<<<< HEAD
    class TemporaryDirectory:
=======
    class TemporaryDirectory(object):
>>>>>>> 6fa881f75740879be432c459b9cab8a7b7aa2895
        """
        Very simple temporary directory context manager.
        Will try to delete afterward, but will also ignore OS and similar
        errors on deletion.
        """

<<<<<<< HEAD
        def __init__(self, **kwargs):
            self.name = None  # Handle mkdtemp raising an exception
            self.name = tempfile.mkdtemp(**kwargs)
=======
        def __init__(self):
            self.name = None  # Handle mkdtemp raising an exception
            self.name = tempfile.mkdtemp()
>>>>>>> 6fa881f75740879be432c459b9cab8a7b7aa2895

        def __enter__(self):
            return self.name

        def __exit__(self, exctype, excvalue, exctrace):
            try:
                shutil.rmtree(self.name, True)
            except OSError:  # removal errors are not the only possible
                pass
            self.name = None
